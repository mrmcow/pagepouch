{"version":3,"file":"background.js","mappings":";;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC/QA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACt/BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["webpack://@pagestash/extension/./src/utils/supabase.ts","webpack://@pagestash/extension/./src/utils/fullPageCapture.ts","webpack://@pagestash/extension/./src/background/index.ts"],"sourcesContent":["// Supabase client for browser extension\n// SECURITY NOTE: Extension does NOT include Supabase credentials\n// All authentication and data operations go through the web app's API\n// Firefox compatibility layer\nconst extensionAPI = typeof browser !== 'undefined' ? browser : chrome;\n// Get the API base URL based on environment\nconst API_BASE_URL = process.env.NODE_ENV === 'production'\n    ? 'https://pagestash.app'\n    : 'http://localhost:3000';\n// Extension-specific auth helpers\nexport class ExtensionAuth {\n    static async signIn(email, password) {\n        console.log('üîê ExtensionAuth.signIn called for:', email);\n        try {\n            const response = await fetch(`${API_BASE_URL}/api/auth/login`, {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json',\n                },\n                body: JSON.stringify({ email, password }),\n            });\n            const result = await response.json();\n            if (!response.ok) {\n                console.error('üîê Login error:', result.error);\n                return { data: null, error: { message: result.error } };\n            }\n            console.log('üîê Login successful:', {\n                hasSession: !!result.session,\n                hasUser: !!result.user,\n            });\n            if (result.session) {\n                console.log('üîê Storing session in extension storage');\n                // Store session in extension storage\n                await extensionAPI.storage.local.set({\n                    authToken: result.session.access_token,\n                    refreshToken: result.session.refresh_token,\n                    userEmail: result.user?.email,\n                    userId: result.user?.id,\n                });\n            }\n            return {\n                data: {\n                    session: result.session,\n                    user: result.user\n                },\n                error: null\n            };\n        }\n        catch (err) {\n            console.error('üîê Login request failed:', err);\n            return {\n                data: null,\n                error: { message: err.message || 'Network error' }\n            };\n        }\n    }\n    static async signUp(email, password, fullName) {\n        try {\n            const response = await fetch(`${API_BASE_URL}/api/auth/signup`, {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json',\n                },\n                body: JSON.stringify({ email, password, fullName }),\n            });\n            const result = await response.json();\n            if (!response.ok) {\n                console.error('üîê Signup error:', result.error);\n                return { data: null, error: { message: result.error } };\n            }\n            if (result.session) {\n                // Store session in extension storage\n                await extensionAPI.storage.local.set({\n                    authToken: result.session.access_token,\n                    refreshToken: result.session.refresh_token,\n                    userEmail: result.user?.email,\n                    userId: result.user?.id,\n                });\n            }\n            return {\n                data: {\n                    session: result.session,\n                    user: result.user\n                },\n                error: null\n            };\n        }\n        catch (err) {\n            console.error('üîê Signup request failed:', err);\n            return {\n                data: null,\n                error: { message: err.message || 'Network error' }\n            };\n        }\n    }\n    static async signOut() {\n        // Just clear local storage - no need to call API for logout\n        await extensionAPI.storage.local.remove([\n            'authToken',\n            'refreshToken',\n            'userEmail',\n            'userId',\n        ]);\n        console.log('üîê Signed out and cleared local storage');\n        return { error: null };\n    }\n    static async restoreSession() {\n        try {\n            const stored = await new Promise((resolve) => {\n                extensionAPI.storage.local.get(['authToken', 'refreshToken', 'userId', 'userEmail'], (result) => {\n                    resolve({\n                        authToken: result.authToken || null,\n                        refreshToken: result.refreshToken || null,\n                        userId: result.userId || null,\n                        userEmail: result.userEmail || null,\n                    });\n                });\n            });\n            // No stored session\n            if (!stored.authToken) {\n                console.log('üîê No stored session found');\n                return false;\n            }\n            console.log('üîê Session found for user:', stored.userEmail);\n            // Token validation will happen when making actual API calls\n            // The API will return 401 if token is invalid, and we'll handle it there\n            return true;\n        }\n        catch (err) {\n            console.error('üîê Session restoration error:', err);\n            await this.signOut();\n            return false;\n        }\n    }\n    static async getSession() {\n        // Get session from local storage\n        return new Promise((resolve) => {\n            extensionAPI.storage.local.get(['authToken', 'userId'], (result) => {\n                resolve({\n                    token: result.authToken || null,\n                    userId: result.userId || null,\n                });\n            });\n        });\n    }\n    static async refreshSession() {\n        // For now, we don't implement token refresh\n        // The API will handle token validation and return 401 if expired\n        // In that case, user will need to sign in again\n        console.log('üîê Token refresh not implemented - user will need to sign in again if token expires');\n        return { data: null, error: new Error('Token refresh not implemented') };\n    }\n}\n// API helpers for extension\nexport class ExtensionAPI {\n    // Get the correct API base URL based on environment\n    static getApiBaseUrl() {\n        // In production, use the deployed web app URL\n        // In development, use localhost\n        return API_BASE_URL;\n    }\n    // Helper method to make authenticated requests with automatic retry\n    static async authenticatedFetch(url, options = {}) {\n        // Ensure session is valid before API call\n        await ExtensionAuth.restoreSession();\n        const { token } = await ExtensionAuth.getSession();\n        if (!token) {\n            throw new Error('Not authenticated');\n        }\n        // Make first request\n        let response = await fetch(url, {\n            ...options,\n            headers: {\n                ...options.headers,\n                'Authorization': `Bearer ${token}`,\n            },\n        });\n        // Handle 401 - token might have expired mid-request\n        if (response.status === 401) {\n            console.log('Token expired, refreshing and retrying...');\n            await ExtensionAuth.refreshSession();\n            // Retry with new token\n            const { token: newToken } = await ExtensionAuth.getSession();\n            if (!newToken) {\n                throw new Error('Authentication failed after refresh');\n            }\n            response = await fetch(url, {\n                ...options,\n                headers: {\n                    ...options.headers,\n                    'Authorization': `Bearer ${newToken}`,\n                },\n            });\n        }\n        return response;\n    }\n    static async saveClip(clipData) {\n        const apiUrl = `${this.getApiBaseUrl()}/api/clips`;\n        console.log('Saving clip to API endpoint:', apiUrl);\n        const response = await this.authenticatedFetch(apiUrl, {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json',\n            },\n            body: JSON.stringify(clipData),\n        });\n        console.log('API response status:', response.status);\n        if (!response.ok) {\n            const errorText = await response.text();\n            console.error('API error response:', errorText);\n            let error;\n            try {\n                error = JSON.parse(errorText);\n            }\n            catch {\n                error = { error: errorText || 'Failed to save clip' };\n            }\n            throw new Error(error.error || 'Failed to save clip');\n        }\n        const result = await response.json();\n        console.log('Clip saved successfully:', result);\n        return result;\n    }\n    static async getClips(params) {\n        const searchParams = new URLSearchParams();\n        if (params?.limit)\n            searchParams.set('limit', params.limit.toString());\n        if (params?.offset)\n            searchParams.set('offset', params.offset.toString());\n        if (params?.folder_id)\n            searchParams.set('folder_id', params.folder_id);\n        if (params?.q)\n            searchParams.set('q', params.q);\n        const response = await this.authenticatedFetch(`${this.getApiBaseUrl()}/api/clips?${searchParams}`);\n        if (!response.ok) {\n            const error = await response.json();\n            throw new Error(error.error || 'Failed to fetch clips');\n        }\n        return response.json();\n    }\n    static async getFolders() {\n        const response = await this.authenticatedFetch(`${this.getApiBaseUrl()}/api/folders`);\n        if (!response.ok) {\n            const error = await response.json();\n            throw new Error(error.error || 'Failed to fetch folders');\n        }\n        return response.json();\n    }\n    static async getUsage() {\n        const response = await this.authenticatedFetch(`${this.getApiBaseUrl()}/api/usage`);\n        if (!response.ok) {\n            const error = await response.json();\n            throw new Error(error.error || 'Failed to fetch usage data');\n        }\n        return response.json();\n    }\n    static async createFolder(folderData) {\n        const response = await this.authenticatedFetch(`${this.getApiBaseUrl()}/api/folders`, {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json',\n            },\n            body: JSON.stringify(folderData),\n        });\n        if (!response.ok) {\n            const error = await response.json();\n            throw new Error(error.error || 'Failed to create folder');\n        }\n        const result = await response.json();\n        return result.folder;\n    }\n}\n","/**\n * Full-page screenshot capture utility\n * Captures entire webpage by scrolling and stitching screenshots\n */\n// Firefox compatibility layer\nconst extensionAPI = typeof browser !== 'undefined' ? browser : chrome;\nexport class FullPageCapture {\n    /**\n     * Capture full page screenshot by scrolling and stitching\n     */\n    static async captureFullPage(tabId, options = {}) {\n        const opts = { ...this.DEFAULT_OPTIONS, ...options };\n        const startTime = Date.now();\n        try {\n            // Verify permissions before starting\n            if (!this.isSupported()) {\n                throw new Error('Full page capture is not supported - missing Chrome APIs or permissions');\n            }\n            // Get page dimensions and current scroll position\n            const pageInfo = await this.getPageInfo(tabId);\n            console.log('Full page capture - Page info:', {\n                scrollHeight: pageInfo.scrollHeight,\n                scrollWidth: pageInfo.scrollWidth,\n                viewportWidth: pageInfo.viewportWidth,\n                viewportHeight: pageInfo.viewportHeight,\n                originalScrollX: pageInfo.originalScrollX,\n                originalScrollY: pageInfo.originalScrollY\n            });\n            if (pageInfo.scrollHeight <= pageInfo.viewportHeight) {\n                // Page fits in viewport, use simple capture\n                console.log('Page fits in viewport, using simple capture');\n                return this.captureVisibleArea(tabId, opts, pageInfo, startTime);\n            }\n            // Firefox needs special handling due to captureVisibleTab limitations\n            const isFirefox = typeof browser !== 'undefined';\n            if (isFirefox) {\n                console.log('üîß Firefox: Using SIMPLE vertical sections - same as visible area');\n                return this.captureVerticalOnlyFirefox(tabId, opts, pageInfo, startTime);\n            }\n            console.log('üîß Chrome: Using full grid capture');\n            // Check if we need horizontal scrolling\n            // Firefox often underreports scrollWidth, so be more aggressive about detecting wide pages\n            const needsHorizontalScroll = pageInfo.scrollWidth > pageInfo.viewportWidth;\n            const forceHorizontalScroll = pageInfo.scrollWidth >= pageInfo.viewportWidth * 1.1; // Force if 10% wider\n            const finalNeedsHorizontalScroll = needsHorizontalScroll || forceHorizontalScroll;\n            console.log('üîß Horizontal scroll analysis:', {\n                scrollWidth: pageInfo.scrollWidth,\n                viewportWidth: pageInfo.viewportWidth,\n                ratio: pageInfo.scrollWidth / pageInfo.viewportWidth,\n                needsHorizontalScroll,\n                forceHorizontalScroll,\n                finalNeedsHorizontalScroll\n            });\n            // Calculate scroll positions for both dimensions\n            const verticalPositions = this.calculateScrollPositions(pageInfo.scrollHeight, pageInfo.viewportHeight, opts.maxHeight);\n            const horizontalPositions = finalNeedsHorizontalScroll\n                ? this.calculateHorizontalScrollPositions(pageInfo.scrollWidth, pageInfo.viewportWidth)\n                : [0];\n            // Capture each section (grid of horizontal x vertical positions)\n            const screenshots = [];\n            const totalSections = verticalPositions.length * horizontalPositions.length;\n            console.log(`üîß Firefox capture grid analysis:`, {\n                verticalPositions: verticalPositions.length,\n                horizontalPositions: horizontalPositions.length,\n                totalSections,\n                verticalPositionsArray: verticalPositions,\n                horizontalPositionsArray: horizontalPositions\n            });\n            console.log(`Capturing ${totalSections} sections...`);\n            for (let vIndex = 0; vIndex < verticalPositions.length; vIndex++) {\n                for (let hIndex = 0; hIndex < horizontalPositions.length; hIndex++) {\n                    const scrollY = verticalPositions[vIndex];\n                    const scrollX = horizontalPositions[hIndex];\n                    const sectionIndex = vIndex * horizontalPositions.length + hIndex + 1;\n                    // Send progress update to popup\n                    try {\n                        const extensionAPI = typeof browser !== 'undefined' ? browser : chrome;\n                        extensionAPI.runtime.sendMessage({\n                            type: 'CAPTURE_PROGRESS',\n                            payload: {\n                                status: 'capturing',\n                                message: `Capturing page... ${sectionIndex} of ${totalSections} sections`,\n                                progress: Math.round((sectionIndex / totalSections) * 100)\n                            }\n                        });\n                    }\n                    catch (e) {\n                        // Ignore messaging errors\n                    }\n                    // Scroll to position\n                    await this.scrollToPosition(tabId, scrollY, scrollX);\n                    // Wait for scroll to complete and content to load\n                    await this.delay(opts.scrollDelay);\n                    // Rate limiting delay between captures (reduced from 800ms to 400ms)\n                    if (sectionIndex > 1) {\n                        await this.delay(400);\n                    }\n                    try {\n                        // Capture visible area with retry logic\n                        const screenshot = await this.captureWithRetry(opts.format, opts.quality, 5);\n                        screenshots.push({ dataUrl: screenshot, x: scrollX, y: scrollY });\n                        // Small delay after successful capture\n                        if (sectionIndex < totalSections) {\n                            await this.delay(150);\n                        }\n                    }\n                    catch (error) {\n                        console.error(`Failed to capture section ${sectionIndex}:`, error);\n                        throw new Error(`Failed to capture section ${sectionIndex}: ${error instanceof Error ? error.message : 'Unknown error'}`);\n                    }\n                }\n            }\n            // Restore original scroll position\n            await this.scrollToPosition(tabId, pageInfo.originalScrollY, pageInfo.originalScrollX);\n            // Stitch screenshots together\n            console.log('Starting image stitching...');\n            const actualWidth = Math.max(pageInfo.viewportWidth, pageInfo.scrollWidth);\n            const actualHeight = Math.min(pageInfo.scrollHeight, opts.maxHeight);\n            console.log('Stitching parameters:', {\n                screenshotCount: screenshots.length,\n                actualWidth,\n                actualHeight,\n                viewportWidth: pageInfo.viewportWidth,\n                viewportHeight: pageInfo.viewportHeight,\n                screenshotPositions: screenshots.map(s => ({ x: s.x, y: s.y }))\n            });\n            const stitchedImage = await this.stitchGridScreenshots(screenshots, actualWidth, actualHeight, pageInfo.viewportWidth, pageInfo.viewportHeight);\n            console.log('Image stitching completed');\n            // Compress the image for API upload to avoid payload size limits\n            console.log('Compressing image for API upload...');\n            // Ultra aggressive compression based on number of sections\n            let compressionQuality = 0.4; // Much lower default\n            if (screenshots.length > 15) {\n                compressionQuality = 0.15; // Ultra aggressive for extremely long pages\n                console.log('üîß Chrome: Extremely long page detected - using ultra compression (15%)');\n            }\n            else if (screenshots.length > 10) {\n                compressionQuality = 0.2; // Very aggressive for very long pages\n                console.log('üîß Chrome: Very long page detected - using aggressive compression (20%)');\n            }\n            else if (screenshots.length > 6) {\n                compressionQuality = 0.3; // Aggressive compression for long pages\n                console.log('üîß Chrome: Long page detected - using aggressive compression (30%)');\n            }\n            else if (screenshots.length > 3) {\n                compressionQuality = 0.35; // Medium compression for medium pages\n                console.log('üîß Chrome: Medium page detected - using medium compression (35%)');\n            }\n            else {\n                console.log('üîß Chrome: Short page - using standard compression (40%)');\n            }\n            const compressedImage = await this.compressImage(stitchedImage, compressionQuality);\n            // Check final size and apply emergency compression if needed\n            const imageSizeMB = (compressedImage.length * 0.75) / (1024 * 1024); // Rough estimate\n            console.log('üîß Chrome: Final image size estimate:', Math.round(imageSizeMB * 100) / 100, 'MB');\n            let finalImage = compressedImage;\n            if (imageSizeMB > 1.5) { // Very low threshold for emergency compression\n                let emergencyQuality = 0.1; // Start with ultra aggressive compression\n                if (imageSizeMB > 3) {\n                    emergencyQuality = 0.08; // Extreme compression for very large images\n                    console.log('üîß Chrome: Image extremely large - applying extreme emergency compression (8%)');\n                }\n                else if (imageSizeMB > 2) {\n                    emergencyQuality = 0.09; // Ultra aggressive for large images\n                    console.log('üîß Chrome: Image very large - applying ultra emergency compression (9%)');\n                }\n                else {\n                    console.log('üîß Chrome: Image too large - applying emergency compression (10%)');\n                }\n                finalImage = await this.compressImage(stitchedImage, emergencyQuality);\n                const emergencySizeMB = (finalImage.length * 0.75) / (1024 * 1024);\n                console.log('üîß Chrome: Emergency compressed size:', Math.round(emergencySizeMB * 100) / 100, 'MB');\n                // Final check - if still too large, apply absolute minimum quality\n                if (emergencySizeMB > 1.2) {\n                    console.log('üîß Chrome: Still too large - applying absolute minimum compression (5%)');\n                    finalImage = await this.compressImage(stitchedImage, 0.05);\n                    const finalSizeMB = (finalImage.length * 0.75) / (1024 * 1024);\n                    console.log('üîß Chrome: Final absolute minimum size:', Math.round(finalSizeMB * 100) / 100, 'MB');\n                }\n            }\n            console.log('Image compression completed');\n            return {\n                dataUrl: finalImage,\n                width: actualWidth,\n                height: Math.min(pageInfo.scrollHeight, opts.maxHeight),\n                scrollHeight: pageInfo.scrollHeight,\n                captureTime: Date.now() - startTime,\n            };\n        }\n        catch (error) {\n            console.error('Full page capture failed:', error);\n            throw new Error(`Full page capture failed: ${error instanceof Error ? error.message : 'Unknown error'}`);\n        }\n    }\n    /**\n     * Firefox SIMPLE capture - exactly like visible area but multiple vertical sections\n     */\n    static async captureVerticalOnlyFirefox(tabId, options, pageInfo, startTime) {\n        console.log('üîß Firefox: SIMPLE vertical sections - same as visible area capture');\n        console.log('üîß Firefox: Page dimensions:', {\n            scrollWidth: pageInfo.scrollWidth,\n            viewportWidth: pageInfo.viewportWidth,\n            scrollHeight: pageInfo.scrollHeight,\n            viewportHeight: pageInfo.viewportHeight\n        });\n        // Calculate vertical positions - same scroll logic as before\n        const verticalPositions = this.calculateScrollPositions(pageInfo.scrollHeight, pageInfo.viewportHeight, options.maxHeight);\n        console.log('üîß Firefox: SIMPLE capture plan:', {\n            verticalSections: verticalPositions.length,\n            captureWidth: pageInfo.viewportWidth, // Use original viewport width\n            totalHeight: pageInfo.scrollHeight,\n            positions: verticalPositions\n        });\n        // Capture vertical screenshots - EXACTLY like visible area\n        const screenshots = [];\n        for (let i = 0; i < verticalPositions.length; i++) {\n            const scrollY = verticalPositions[i];\n            console.log(`üîß Firefox: SIMPLE capture section ${i + 1}/${verticalPositions.length} at Y=${scrollY}`);\n            // Scroll to position\n            await this.scrollToPosition(tabId, scrollY, 0);\n            await this.delay(options.scrollDelay);\n            // Rate limiting\n            if (i > 0) {\n                await this.delay(600);\n            }\n            try {\n                // EXACT SAME CAPTURE as visible area - this works perfectly!\n                const screenshot = await extensionAPI.tabs.captureVisibleTab({\n                    format: options.format,\n                    quality: options.quality\n                });\n                screenshots.push(screenshot);\n                console.log(`üîß Firefox: SIMPLE section ${i + 1} captured successfully`);\n            }\n            catch (error) {\n                console.error(`üîß Firefox: SIMPLE capture failed section ${i + 1}:`, error);\n                throw new Error(`Failed to capture section ${i + 1}: ${error instanceof Error ? error.message : 'Unknown error'}`);\n            }\n        }\n        // Restore original scroll position\n        await this.scrollToPosition(tabId, pageInfo.originalScrollY, pageInfo.originalScrollX);\n        // Stitch vertical screenshots - simple and clean\n        console.log('üîß Firefox: SIMPLE vertical stitching', screenshots.length, 'screenshots');\n        const stitchedImage = await this.stitchFirefoxVertical(screenshots, pageInfo.viewportWidth, // Use original viewport width\n        pageInfo.viewportHeight);\n        // Ultra aggressive compression to stay under payload limits\n        let compressionQuality = 0.4; // Much lower default\n        if (screenshots.length > 15) {\n            compressionQuality = 0.15; // Ultra aggressive for extremely long pages\n            console.log('üîß Firefox: Extremely long page detected - using ultra compression (15%)');\n        }\n        else if (screenshots.length > 10) {\n            compressionQuality = 0.2; // Very aggressive for very long pages\n            console.log('üîß Firefox: Very long page detected - using aggressive compression (20%)');\n        }\n        else if (screenshots.length > 6) {\n            compressionQuality = 0.3; // Aggressive compression for long pages\n            console.log('üîß Firefox: Long page detected - using aggressive compression (30%)');\n        }\n        else if (screenshots.length > 3) {\n            compressionQuality = 0.35; // Medium compression for medium pages\n            console.log('üîß Firefox: Medium page detected - using medium compression (35%)');\n        }\n        else {\n            console.log('üîß Firefox: Short page - using standard compression (40%)');\n        }\n        const compressedImage = await this.compressImage(stitchedImage, compressionQuality);\n        // Check final size and apply emergency compression if needed\n        const imageSizeMB = (compressedImage.length * 0.75) / (1024 * 1024); // Rough estimate\n        console.log('üîß Firefox: Final image size estimate:', Math.round(imageSizeMB * 100) / 100, 'MB');\n        let finalImage = compressedImage;\n        if (imageSizeMB > 1.5) { // Very low threshold for emergency compression\n            let emergencyQuality = 0.1; // Start with ultra aggressive compression\n            if (imageSizeMB > 3) {\n                emergencyQuality = 0.08; // Extreme compression for very large images\n                console.log('üîß Firefox: Image extremely large - applying extreme emergency compression (8%)');\n            }\n            else if (imageSizeMB > 2) {\n                emergencyQuality = 0.09; // Ultra aggressive for large images\n                console.log('üîß Firefox: Image very large - applying ultra emergency compression (9%)');\n            }\n            else {\n                console.log('üîß Firefox: Image too large - applying emergency compression (10%)');\n            }\n            finalImage = await this.compressImage(stitchedImage, emergencyQuality);\n            const emergencySizeMB = (finalImage.length * 0.75) / (1024 * 1024);\n            console.log('üîß Firefox: Emergency compressed size:', Math.round(emergencySizeMB * 100) / 100, 'MB');\n            // Final check - if still too large, apply absolute minimum quality\n            if (emergencySizeMB > 1.2) {\n                console.log('üîß Firefox: Still too large - applying absolute minimum compression (5%)');\n                finalImage = await this.compressImage(stitchedImage, 0.05);\n                const finalSizeMB = (finalImage.length * 0.75) / (1024 * 1024);\n                console.log('üîß Firefox: Final absolute minimum size:', Math.round(finalSizeMB * 100) / 100, 'MB');\n            }\n        }\n        return {\n            dataUrl: finalImage,\n            width: pageInfo.viewportWidth, // Report original viewport width\n            height: pageInfo.scrollHeight,\n            scrollHeight: pageInfo.scrollHeight,\n            captureTime: Date.now() - startTime,\n        };\n    }\n    /**\n     * Firefox GRID stitching - handles horizontal + vertical grid perfectly\n     */\n    static async stitchFirefoxGrid(screenshots, totalWidth, totalHeight, viewportWidth, viewportHeight, verticalSections, horizontalSections) {\n        try {\n            console.log('üîß Firefox: BULLETPROOF grid stitching');\n            console.log('üîß Firefox: Grid dimensions:', {\n                totalWidth,\n                totalHeight,\n                viewportWidth,\n                viewportHeight,\n                verticalSections,\n                horizontalSections,\n                totalScreenshots: screenshots.length\n            });\n            const canvas = new OffscreenCanvas(totalWidth, totalHeight);\n            const ctx = canvas.getContext('2d');\n            if (!ctx) {\n                throw new Error('Failed to get OffscreenCanvas context');\n            }\n            // Calculate overlaps\n            const verticalOverlap = Math.floor(viewportHeight * 0.1); // 90px\n            const horizontalOverlap = Math.floor(viewportWidth * 0.1); // 128px\n            console.log('üîß Firefox: Grid overlaps:', {\n                verticalOverlap,\n                horizontalOverlap\n            });\n            // Sort screenshots by position for predictable processing\n            screenshots.sort((a, b) => {\n                if (a.y !== b.y)\n                    return a.y - b.y;\n                return a.x - b.x;\n            });\n            // Process each screenshot in grid order\n            for (let vIndex = 0; vIndex < verticalSections; vIndex++) {\n                for (let hIndex = 0; hIndex < horizontalSections; hIndex++) {\n                    const screenshotIndex = vIndex * horizontalSections + hIndex;\n                    if (screenshotIndex >= screenshots.length) {\n                        console.warn(`üîß Firefox: Missing screenshot at V${vIndex + 1}H${hIndex + 1}`);\n                        continue;\n                    }\n                    const screenshot = screenshots[screenshotIndex];\n                    console.log(`üîß Firefox: Processing V${vIndex + 1}H${hIndex + 1} at (${screenshot.x}, ${screenshot.y})`);\n                    // Convert data URL to ImageBitmap\n                    const response = await fetch(screenshot.dataUrl);\n                    const blob = await response.blob();\n                    const imageBitmap = await createImageBitmap(blob);\n                    // Calculate destination position on canvas\n                    const destX = hIndex === 0 ? 0 : (viewportWidth - horizontalOverlap) * hIndex;\n                    const destY = vIndex === 0 ? 0 : (viewportHeight - verticalOverlap) * vIndex;\n                    // Calculate source area (skip overlaps for non-first sections)\n                    const sourceX = hIndex > 0 ? horizontalOverlap : 0;\n                    const sourceY = vIndex > 0 ? verticalOverlap : 0;\n                    const sourceWidth = hIndex > 0 ? viewportWidth - horizontalOverlap : viewportWidth;\n                    const sourceHeight = vIndex > 0 ? viewportHeight - verticalOverlap : viewportHeight;\n                    console.log(`üîß Firefox: V${vIndex + 1}H${hIndex + 1} -> Canvas(${destX}, ${destY}) from Source(${sourceX}, ${sourceY}, ${sourceWidth}x${sourceHeight})`);\n                    // Draw the image section\n                    ctx.drawImage(imageBitmap, sourceX, sourceY, sourceWidth, sourceHeight, // Source rectangle\n                    destX, destY, sourceWidth, sourceHeight // Destination rectangle\n                    );\n                    // Clean up\n                    imageBitmap.close();\n                }\n            }\n            console.log('üîß Firefox: BULLETPROOF grid stitching completed');\n            // Convert to data URL\n            const blob = await canvas.convertToBlob({ type: 'image/png' });\n            return new Promise((resolve, reject) => {\n                const reader = new FileReader();\n                reader.onload = () => resolve(reader.result);\n                reader.onerror = () => reject(new Error('Failed to convert blob to data URL'));\n                reader.readAsDataURL(blob);\n            });\n        }\n        catch (error) {\n            console.error('üîß Firefox: BULLETPROOF grid stitching failed:', error);\n            // Fallback: return first screenshot\n            return screenshots[0]?.dataUrl || '';\n        }\n    }\n    /**\n     * DEAD SIMPLE vertical stitching - just stack images with NO width changes\n     */\n    static async stitchFirefoxVertical(screenshots, width, viewportHeight) {\n        try {\n            console.log('üîß Firefox: DEAD SIMPLE vertical stacking - NO width manipulation');\n            if (screenshots.length === 0) {\n                throw new Error('No screenshots to stitch');\n            }\n            if (screenshots.length === 1) {\n                console.log('üîß Firefox: Single screenshot, returning as-is');\n                return screenshots[0];\n            }\n            // Get actual dimensions from first screenshot\n            const firstResponse = await fetch(screenshots[0]);\n            const firstBlob = await firstResponse.blob();\n            const firstImage = await createImageBitmap(firstBlob);\n            const actualWidth = firstImage.naturalWidth || firstImage.width;\n            const actualHeight = firstImage.naturalHeight || firstImage.height;\n            console.log('üîß Firefox: Actual screenshot dimensions:', {\n                actualWidth,\n                actualHeight,\n                providedWidth: width,\n                providedHeight: viewportHeight,\n                screenshots: screenshots.length\n            });\n            // Calculate total height - simple stacking with 10% overlap removal\n            const overlapPixels = Math.floor(actualHeight * 0.1);\n            const sectionHeight = actualHeight - overlapPixels;\n            const totalHeight = actualHeight + (sectionHeight * (screenshots.length - 1));\n            console.log('üîß Firefox: SIMPLE stacking plan:', {\n                actualWidth,\n                totalHeight,\n                overlapPixels,\n                sectionHeight,\n                sections: screenshots.length\n            });\n            // Create canvas with ACTUAL screenshot dimensions\n            const canvas = new OffscreenCanvas(actualWidth, totalHeight);\n            const ctx = canvas.getContext('2d');\n            if (!ctx) {\n                throw new Error('Failed to get OffscreenCanvas context');\n            }\n            let currentY = 0;\n            for (let i = 0; i < screenshots.length; i++) {\n                const screenshot = screenshots[i];\n                // Convert data URL to ImageBitmap\n                const response = await fetch(screenshot);\n                const blob = await response.blob();\n                const imageBitmap = await createImageBitmap(blob);\n                console.log(`üîß Firefox: SIMPLE stacking section ${i + 1} at Y=${currentY}`);\n                if (i === 0) {\n                    // First image - draw completely at Y=0\n                    ctx.drawImage(imageBitmap, 0, 0);\n                    currentY = actualHeight;\n                }\n                else {\n                    // Subsequent images - skip overlap from top, draw at currentY - overlapPixels\n                    const drawY = currentY - overlapPixels;\n                    ctx.drawImage(imageBitmap, 0, overlapPixels, // Source: skip overlap from top\n                    imageBitmap.width, imageBitmap.height - overlapPixels, // Source dimensions\n                    0, drawY, // Destination\n                    imageBitmap.width, imageBitmap.height - overlapPixels // Destination dimensions\n                    );\n                    currentY += (imageBitmap.height - overlapPixels);\n                }\n                // Clean up\n                imageBitmap.close();\n            }\n            // Clean up first image\n            firstImage.close();\n            console.log('üîß Firefox: SIMPLE stacking completed - final size:', actualWidth, 'x', totalHeight);\n            // Convert to data URL\n            const blob = await canvas.convertToBlob({ type: 'image/png' });\n            return new Promise((resolve, reject) => {\n                const reader = new FileReader();\n                reader.onload = () => resolve(reader.result);\n                reader.onerror = () => reject(new Error('Failed to convert blob to data URL'));\n                reader.readAsDataURL(blob);\n            });\n        }\n        catch (error) {\n            console.error('üîß Firefox: SIMPLE stacking failed:', error);\n            // Fallback: return first screenshot\n            return screenshots[0] || '';\n        }\n    }\n    /**\n     * Get page information needed for capture\n     */\n    static async getPageInfo(tabId) {\n        const results = await this.executeScript(tabId, () => {\n            // Enhanced dimension calculation for Firefox compatibility\n            const bodyScrollWidth = document.body.scrollWidth || 0;\n            const bodyOffsetWidth = document.body.offsetWidth || 0;\n            const docScrollWidth = document.documentElement.scrollWidth || 0;\n            const docOffsetWidth = document.documentElement.offsetWidth || 0;\n            const docClientWidth = document.documentElement.clientWidth || 0;\n            // Firefox-specific: More aggressive width detection\n            // Check all possible width measurements and find the true content width\n            const allWidthMeasurements = [\n                bodyScrollWidth,\n                bodyOffsetWidth,\n                docScrollWidth,\n                docOffsetWidth,\n                docClientWidth,\n                window.innerWidth,\n                window.outerWidth,\n                screen.width\n            ];\n            // Also check for elements that might extend beyond viewport\n            let maxElementWidth = 0;\n            try {\n                const allElements = document.querySelectorAll('*');\n                for (let i = 0; i < Math.min(allElements.length, 100); i++) { // Check first 100 elements\n                    const element = allElements[i];\n                    const rect = element.getBoundingClientRect();\n                    const elementRight = rect.right + window.scrollX;\n                    if (elementRight > maxElementWidth) {\n                        maxElementWidth = elementRight;\n                    }\n                }\n            }\n            catch (e) {\n                console.warn('Could not check element widths:', e);\n            }\n            allWidthMeasurements.push(maxElementWidth);\n            const contentWidth = Math.max(...allWidthMeasurements);\n            // Firefox often underreports width, so add a safety margin if we detect potential issues\n            const finalWidth = contentWidth > window.innerWidth ? contentWidth : Math.max(contentWidth, window.innerWidth * 1.2);\n            console.log('üîß Firefox page dimensions debug:', {\n                bodyScrollWidth,\n                bodyOffsetWidth,\n                docScrollWidth,\n                docOffsetWidth,\n                docClientWidth,\n                windowInnerWidth: window.innerWidth,\n                windowOuterWidth: window.outerWidth,\n                screenWidth: screen.width,\n                maxElementWidth,\n                calculatedContentWidth: contentWidth,\n                finalWidth,\n                allMeasurements: allWidthMeasurements\n            });\n            return {\n                scrollHeight: Math.max(document.body.scrollHeight, document.body.offsetHeight, document.documentElement.clientHeight, document.documentElement.scrollHeight, document.documentElement.offsetHeight),\n                scrollWidth: finalWidth,\n                viewportWidth: window.innerWidth,\n                viewportHeight: window.innerHeight,\n                originalScrollY: window.scrollY,\n                originalScrollX: window.scrollX,\n            };\n        });\n        if (!results || !results[0]) {\n            throw new Error('Failed to get page information');\n        }\n        return results[0];\n    }\n    /**\n     * Calculate optimal scroll positions for capture\n     */\n    static calculateScrollPositions(scrollHeight, viewportHeight, maxHeight) {\n        const positions = [];\n        const effectiveHeight = Math.min(scrollHeight, maxHeight);\n        console.log('üîß Calculating vertical positions:', { scrollHeight, viewportHeight, effectiveHeight });\n        // Use percentage-based overlap to match stitching logic\n        const overlap = Math.floor(viewportHeight * 0.1); // 10% overlap to match stitching\n        const step = viewportHeight - overlap;\n        let currentY = 0;\n        // Capture sections with small overlap\n        while (currentY < effectiveHeight) {\n            positions.push(currentY);\n            currentY += step;\n            // Stop if we're close to the end\n            if (currentY >= effectiveHeight - viewportHeight) {\n                break;\n            }\n        }\n        // Always ensure we capture the absolute bottom\n        const bottomPosition = Math.max(0, effectiveHeight - viewportHeight);\n        if (!positions.includes(bottomPosition) && bottomPosition > 0) {\n            positions.push(bottomPosition);\n        }\n        console.log('üîß Vertical positions calculated:', positions);\n        return positions;\n    }\n    /**\n     * Calculate horizontal scroll positions for wide pages\n     */\n    static calculateHorizontalScrollPositions(scrollWidth, viewportWidth) {\n        const positions = [];\n        console.log('üîß Calculating horizontal positions:', { scrollWidth, viewportWidth });\n        // Always start at 0\n        positions.push(0);\n        // If content is wider than viewport, calculate overlapping positions\n        if (scrollWidth > viewportWidth) {\n            // Calculate how much we need to scroll to capture remaining width\n            // We want overlap, not gaps!\n            const overlap = Math.floor(viewportWidth * 0.1); // 10% overlap\n            const step = viewportWidth - overlap;\n            let currentPos = 0;\n            while (currentPos + viewportWidth < scrollWidth) {\n                currentPos += step;\n                if (currentPos > 0 && !positions.includes(currentPos)) {\n                    positions.push(currentPos);\n                }\n            }\n            // CRITICAL FIX: Always capture the rightmost edge!\n            // This ensures we don't cut off the right side of the page\n            const rightmostPosition = Math.max(0, scrollWidth - viewportWidth);\n            if (!positions.includes(rightmostPosition) && rightmostPosition > 0) {\n                positions.push(rightmostPosition);\n            }\n        }\n        console.log('üîß Horizontal positions calculated:', positions);\n        return positions;\n    }\n    /**\n     * Scroll to specific position\n     */\n    static async scrollToPosition(tabId, scrollY, scrollX = 0) {\n        await this.executeScript(tabId, (x, y) => {\n            window.scrollTo(x, y);\n        }, [scrollX, scrollY]);\n    }\n    /**\n     * Capture visible area (fallback for single-viewport pages)\n     */\n    static async captureVisibleArea(tabId, options, pageInfo, startTime) {\n        const screenshot = await extensionAPI.tabs.captureVisibleTab({\n            format: options.format,\n            quality: options.quality,\n        });\n        return {\n            dataUrl: screenshot,\n            width: pageInfo.viewportWidth,\n            height: pageInfo.viewportHeight,\n            scrollHeight: pageInfo.scrollHeight,\n            captureTime: Date.now() - startTime,\n        };\n    }\n    /**\n     * Stitch multiple screenshots into single image using OffscreenCanvas\n     */\n    static async stitchScreenshots(screenshots, width, viewportHeight, scrollPositions) {\n        try {\n            // Use OffscreenCanvas for service worker compatibility\n            const totalHeight = scrollPositions[scrollPositions.length - 1] + viewportHeight;\n            const canvas = new OffscreenCanvas(width, totalHeight);\n            const ctx = canvas.getContext('2d');\n            if (!ctx) {\n                throw new Error('Failed to get OffscreenCanvas context');\n            }\n            // Load and process images sequentially to avoid memory issues\n            for (let i = 0; i < screenshots.length; i++) {\n                const screenshot = screenshots[i];\n                const scrollY = scrollPositions[i];\n                // Convert data URL to ImageBitmap\n                const response = await fetch(screenshot);\n                const blob = await response.blob();\n                const imageBitmap = await createImageBitmap(blob);\n                if (i === 0) {\n                    // First image - draw completely\n                    ctx.drawImage(imageBitmap, 0, scrollY);\n                }\n                else {\n                    // Subsequent images - calculate overlap and draw only new content\n                    const prevY = scrollPositions[i - 1];\n                    const overlap = (prevY + viewportHeight) - scrollY;\n                    if (overlap > 0) {\n                        // Draw only the non-overlapping part\n                        ctx.drawImage(imageBitmap, 0, overlap, // Source x, y\n                        imageBitmap.width, imageBitmap.height - overlap, // Source width, height\n                        0, scrollY + overlap, // Dest x, y\n                        imageBitmap.width, imageBitmap.height - overlap // Dest width, height\n                        );\n                    }\n                    else {\n                        // No overlap, draw completely\n                        ctx.drawImage(imageBitmap, 0, scrollY);\n                    }\n                }\n                // Clean up ImageBitmap to free memory\n                imageBitmap.close();\n            }\n            // Convert to blob and then to data URL\n            const blob = await canvas.convertToBlob({ type: 'image/png' });\n            return new Promise((resolve, reject) => {\n                const reader = new FileReader();\n                reader.onload = () => resolve(reader.result);\n                reader.onerror = () => reject(new Error('Failed to convert blob to data URL'));\n                reader.readAsDataURL(blob);\n            });\n        }\n        catch (error) {\n            console.error('Stitching failed:', error);\n            // Fallback: return the first screenshot if stitching fails\n            return screenshots[0] || '';\n        }\n    }\n    /**\n     * Stitch grid of screenshots into single image using OffscreenCanvas\n     */\n    static async stitchGridScreenshots(screenshots, totalWidth, totalHeight, viewportWidth, viewportHeight) {\n        try {\n            console.log('Stitching grid screenshots:', {\n                totalScreenshots: screenshots.length,\n                totalWidth,\n                totalHeight,\n                viewportWidth,\n                viewportHeight\n            });\n            // Use OffscreenCanvas for service worker compatibility\n            const canvas = new OffscreenCanvas(totalWidth, totalHeight);\n            const ctx = canvas.getContext('2d');\n            if (!ctx) {\n                throw new Error('Failed to get OffscreenCanvas context');\n            }\n            // Sort screenshots by position (top-to-bottom, left-to-right)\n            screenshots.sort((a, b) => {\n                if (a.y !== b.y)\n                    return a.y - b.y;\n                return a.x - b.x;\n            });\n            // Calculate overlap amounts\n            const verticalOverlap = Math.floor(viewportHeight * 0.1);\n            const horizontalOverlap = Math.floor(viewportWidth * 0.1);\n            console.log('üîß Stitching with standard overlaps:', {\n                verticalOverlap,\n                horizontalOverlap,\n                viewportWidth,\n                viewportHeight\n            });\n            // Group screenshots by rows\n            const rows = new Map();\n            screenshots.forEach(screenshot => {\n                if (!rows.has(screenshot.y)) {\n                    rows.set(screenshot.y, []);\n                }\n                rows.get(screenshot.y).push(screenshot);\n            });\n            // Process each row\n            const sortedRowKeys = Array.from(rows.keys()).sort((a, b) => a - b);\n            for (let rowIndex = 0; rowIndex < sortedRowKeys.length; rowIndex++) {\n                const rowY = sortedRowKeys[rowIndex];\n                const rowScreenshots = rows.get(rowY);\n                // Sort screenshots in this row by x position\n                rowScreenshots.sort((a, b) => a.x - b.x);\n                for (let colIndex = 0; colIndex < rowScreenshots.length; colIndex++) {\n                    const screenshot = rowScreenshots[colIndex];\n                    // Convert data URL to ImageBitmap\n                    const response = await fetch(screenshot.dataUrl);\n                    const blob = await response.blob();\n                    const imageBitmap = await createImageBitmap(blob);\n                    // CRITICAL FIX: Use the screenshot's ACTUAL scroll position as the canvas position\n                    // This properly handles irregular grids (like rightmost edge captures)\n                    const canvasX = screenshot.x;\n                    const canvasY = screenshot.y;\n                    // Calculate overlaps based on previous screenshots\n                    let sourceX = 0;\n                    let sourceY = 0;\n                    let sourceWidth = imageBitmap.width;\n                    let sourceHeight = imageBitmap.height;\n                    // Handle horizontal overlap with previous column in same row\n                    if (colIndex > 0) {\n                        const prevScreenshot = rowScreenshots[colIndex - 1];\n                        const prevEndX = prevScreenshot.x + viewportWidth;\n                        if (prevEndX > canvasX) {\n                            // There's overlap - skip it from source\n                            const overlap = prevEndX - canvasX;\n                            sourceX = overlap;\n                            sourceWidth -= overlap;\n                        }\n                    }\n                    // Handle vertical overlap with previous row\n                    if (rowIndex > 0) {\n                        const prevRowY = sortedRowKeys[rowIndex - 1];\n                        const prevEndY = prevRowY + viewportHeight;\n                        if (prevEndY > canvasY) {\n                            // There's overlap - skip it from source\n                            const overlap = prevEndY - canvasY;\n                            sourceY = overlap;\n                            sourceHeight -= overlap;\n                        }\n                    }\n                    // Draw the non-overlapping portion at the correct canvas position\n                    ctx.drawImage(imageBitmap, sourceX, sourceY, sourceWidth, sourceHeight, // Source rectangle (skip overlaps)\n                    canvasX + sourceX, canvasY + sourceY, sourceWidth, sourceHeight // Destination rectangle\n                    );\n                    // Clean up ImageBitmap to free memory\n                    imageBitmap.close();\n                }\n            }\n            // Convert to blob and then to data URL\n            const blob = await canvas.convertToBlob({ type: 'image/png' });\n            return new Promise((resolve, reject) => {\n                const reader = new FileReader();\n                reader.onload = () => resolve(reader.result);\n                reader.onerror = () => reject(new Error('Failed to convert blob to data URL'));\n                reader.readAsDataURL(blob);\n            });\n        }\n        catch (error) {\n            console.error('Grid stitching failed:', error);\n            // Fallback: return the first screenshot if stitching fails\n            return screenshots[0]?.dataUrl || '';\n        }\n    }\n    /**\n     * Capture with retry logic for rate limiting and permissions\n     */\n    static async captureWithRetry(format, quality, maxRetries) {\n        for (let attempt = 1; attempt <= maxRetries; attempt++) {\n            try {\n                // Check permissions before attempting capture\n                if (!extensionAPI.tabs || typeof extensionAPI.tabs.captureVisibleTab !== 'function') {\n                    throw new Error('Chrome tabs API not available');\n                }\n                const screenshot = await extensionAPI.tabs.captureVisibleTab({\n                    format,\n                    quality,\n                });\n                return screenshot;\n            }\n            catch (error) {\n                const errorMessage = error instanceof Error ? error.message : String(error);\n                console.log(`Capture attempt ${attempt}/${maxRetries} failed:`, errorMessage);\n                // Handle rate limiting\n                if (errorMessage.includes('MAX_CAPTURE_VISIBLE_TAB_CALLS_PER_SECOND')) {\n                    console.log(`Rate limit hit on attempt ${attempt}/${maxRetries}, waiting...`);\n                    if (attempt < maxRetries) {\n                        // More aggressive backoff: 2s, 4s, 8s...\n                        const waitTime = Math.pow(2, attempt) * 1000;\n                        await this.delay(waitTime);\n                        continue;\n                    }\n                }\n                // Handle permission errors\n                if (errorMessage.includes('permission') || errorMessage.includes('activeTab') || errorMessage.includes('all_urls')) {\n                    console.log(`Permission error on attempt ${attempt}/${maxRetries}, waiting longer...`);\n                    if (attempt < maxRetries) {\n                        // Wait longer for permission issues: 3s, 6s, 12s...\n                        const waitTime = Math.pow(2, attempt) * 1500;\n                        await this.delay(waitTime);\n                        continue;\n                    }\n                }\n                // For other errors, wait a bit before retrying\n                if (attempt < maxRetries) {\n                    console.log(`Generic error, waiting before retry...`);\n                    await this.delay(1000 * attempt);\n                    continue;\n                }\n                // Re-throw if max retries reached\n                throw error;\n            }\n        }\n        throw new Error('Max retries exceeded for capture');\n    }\n    /**\n     * Utility delay function\n     */\n    static delay(ms) {\n        return new Promise(resolve => setTimeout(resolve, ms));\n    }\n    /**\n     * Execute script with browser compatibility\n     */\n    static async executeScript(tabId, func, args) {\n        if (extensionAPI?.scripting && typeof extensionAPI.scripting.executeScript === 'function') {\n            // Chrome Manifest V3 approach\n            console.log('üîß Using scripting.executeScript (Chrome)');\n            const results = await extensionAPI.scripting.executeScript({\n                target: { tabId },\n                func,\n                args\n            });\n            return results.map(result => result.result);\n        }\n        else if (extensionAPI?.tabs && typeof extensionAPI.tabs.executeScript === 'function') {\n            // Firefox Manifest V2 approach\n            console.log('üîß Using tabs.executeScript (Firefox)');\n            return new Promise((resolve, reject) => {\n                const code = args ? `(${func.toString()})(${args.map(arg => JSON.stringify(arg)).join(', ')})` : `(${func.toString()})()`;\n                extensionAPI.tabs.executeScript(tabId, { code }, (results) => {\n                    if (extensionAPI.runtime.lastError) {\n                        reject(new Error(extensionAPI.runtime.lastError.message));\n                    }\n                    else {\n                        resolve(results || []);\n                    }\n                });\n            });\n        }\n        else {\n            throw new Error('No script execution API available');\n        }\n    }\n    /**\n     * Firefox stitching with proper overlap handling\n     */\n    static async stitchFirefoxScreenshotsWithOverlap(screenshots, width, viewportHeight, totalHeight, scrollPositions, overlap) {\n        try {\n            console.log('üîß Firefox PRECISION stitching:', {\n                screenshots: screenshots.length,\n                targetWidth: width,\n                viewportHeight,\n                totalHeight,\n                scrollPositions,\n                overlap\n            });\n            // Create canvas with exact dimensions\n            const canvas = new OffscreenCanvas(width, totalHeight);\n            const ctx = canvas.getContext('2d');\n            if (!ctx) {\n                throw new Error('Failed to get canvas context');\n            }\n            // Fill with white background\n            ctx.fillStyle = '#ffffff';\n            ctx.fillRect(0, 0, width, totalHeight);\n            // Stack images with proper overlap handling\n            for (let i = 0; i < screenshots.length; i++) {\n                const screenshot = screenshots[i];\n                const scrollY = scrollPositions[i];\n                console.log(`üîß Firefox: Stitching section ${i + 1} at scroll Y=${scrollY}`);\n                // Convert data URL to ImageBitmap\n                const response = await fetch(screenshot);\n                const blob = await response.blob();\n                const imageBitmap = await createImageBitmap(blob);\n                if (i === 0) {\n                    // First image - draw completely\n                    ctx.drawImage(imageBitmap, 0, 0, width, viewportHeight, 0, 0, width, viewportHeight);\n                    console.log(`üîß Firefox: Drew first section at Y=0`);\n                }\n                else {\n                    // Subsequent images - handle overlap\n                    const prevScrollY = scrollPositions[i - 1];\n                    const expectedOverlap = Math.max(0, (prevScrollY + viewportHeight) - scrollY);\n                    const sourceY = Math.min(expectedOverlap, overlap);\n                    const sourceHeight = viewportHeight - sourceY;\n                    const destY = scrollY + sourceY;\n                    if (sourceHeight > 0 && destY < totalHeight) {\n                        const finalHeight = Math.min(sourceHeight, totalHeight - destY);\n                        ctx.drawImage(imageBitmap, 0, sourceY, width, finalHeight, // Source\n                        0, destY, width, finalHeight // Destination\n                        );\n                        console.log(`üîß Firefox: Drew section ${i + 1} from sourceY=${sourceY} to destY=${destY}, height=${finalHeight}`);\n                    }\n                }\n                imageBitmap.close();\n            }\n            console.log(`üîß Firefox: Stitching completed, canvas height: ${totalHeight}`);\n            // Convert to data URL\n            const blob = await canvas.convertToBlob({ type: 'image/png' });\n            return new Promise((resolve, reject) => {\n                const reader = new FileReader();\n                reader.onload = () => resolve(reader.result);\n                reader.onerror = reject;\n                reader.readAsDataURL(blob);\n            });\n        }\n        catch (error) {\n            console.error('üîß Firefox stitching failed:', error);\n            // Fallback to first screenshot\n            return screenshots[0] || '';\n        }\n    }\n    /**\n     * Compress image to reduce payload size for API upload\n     */\n    static async compressImage(dataUrl, quality = 0.7) {\n        try {\n            // Convert data URL to blob\n            const response = await fetch(dataUrl);\n            const blob = await response.blob();\n            // Create ImageBitmap (works in service workers, unlike Image())\n            const imageBitmap = await createImageBitmap(blob);\n            // Create canvas for compression\n            const canvas = new OffscreenCanvas(imageBitmap.width, imageBitmap.height);\n            const ctx = canvas.getContext('2d');\n            if (!ctx) {\n                throw new Error('Failed to get canvas context for compression');\n            }\n            // Draw image to canvas\n            ctx.drawImage(imageBitmap, 0, 0);\n            // Convert to compressed JPEG\n            const compressedBlob = await canvas.convertToBlob({\n                type: 'image/jpeg',\n                quality: quality\n            });\n            // Convert blob back to data URL\n            return new Promise((resolve, reject) => {\n                const reader = new FileReader();\n                reader.onload = () => resolve(reader.result);\n                reader.onerror = reject;\n                reader.readAsDataURL(compressedBlob);\n            });\n        }\n        catch (error) {\n            console.error('Image compression failed:', error);\n            return dataUrl; // Fallback to original if compression fails\n        }\n    }\n    /**\n     * Check if full page capture is supported\n     */\n    static isSupported() {\n        console.log('üîß Checking FullPageCapture support...');\n        console.log('üîß extensionAPI available:', !!extensionAPI);\n        console.log('üîß tabs API available:', !!extensionAPI?.tabs);\n        console.log('üîß captureVisibleTab available:', typeof extensionAPI?.tabs?.captureVisibleTab === 'function');\n        console.log('üîß scripting API available:', !!extensionAPI?.scripting);\n        console.log('üîß executeScript available:', typeof extensionAPI?.scripting?.executeScript === 'function');\n        console.log('üîß tabs.executeScript available:', typeof extensionAPI?.tabs?.executeScript === 'function');\n        // Firefox uses tabs.executeScript (Manifest V2), Chrome uses scripting.executeScript (Manifest V3)\n        const hasScriptExecution = !!((extensionAPI?.scripting && typeof extensionAPI.scripting.executeScript === 'function') ||\n            (extensionAPI?.tabs && typeof extensionAPI.tabs.executeScript === 'function'));\n        const isSupported = !!(extensionAPI &&\n            extensionAPI.tabs &&\n            typeof extensionAPI.tabs.captureVisibleTab === 'function' &&\n            hasScriptExecution);\n        console.log('üîß hasScriptExecution:', hasScriptExecution);\n        console.log('üîß FullPageCapture isSupported:', isSupported);\n        return isSupported;\n    }\n}\nFullPageCapture.DEFAULT_OPTIONS = {\n    quality: 90,\n    format: 'png',\n    maxHeight: 32767, // Maximum canvas height in most browsers\n    scrollDelay: 1000, // More conservative delay to respect Chrome's rate limits\n};\n","// PageStash Extension Background Script\n// Service Worker for Manifest V3\nimport { ExtensionAuth, ExtensionAPI } from '../utils/supabase';\nimport { FullPageCapture } from '../utils/fullPageCapture';\n// Debug mode - set to true for verbose logging\nconst DEBUG = false;\nconst log = (...args) => {\n    if (DEBUG)\n        console.log(...args);\n};\nconsole.log('PageStash background script loaded');\n// Firefox compatibility layer\nconst extensionAPI = typeof browser !== 'undefined' ? browser : chrome;\n// Session monitor state\nlet sessionRefreshInterval = null;\n// Handle extension installation\nextensionAPI.runtime.onInstalled.addListener((details) => {\n    console.log('PageStash extension installed:', details.reason);\n    if (details.reason === 'install') {\n        // Set up initial extension state\n        extensionAPI.storage.local.set({\n            isFirstRun: true,\n            captureCount: 0,\n        });\n    }\n    // Restore session on installation\n    ExtensionAuth.restoreSession().then(() => {\n        startSessionMonitor();\n    });\n});\n// Restore session on browser startup\nif (extensionAPI.runtime.onStartup) {\n    extensionAPI.runtime.onStartup.addListener(async () => {\n        console.log('üîê Extension startup - restoring session');\n        await ExtensionAuth.restoreSession();\n        startSessionMonitor();\n    });\n}\n// Session monitor - checks if session exists\nfunction startSessionMonitor() {\n    // Clear existing interval\n    if (sessionRefreshInterval) {\n        clearInterval(sessionRefreshInterval);\n    }\n    // Check session every 5 minutes\n    sessionRefreshInterval = setInterval(async () => {\n        try {\n            const { token } = await ExtensionAuth.getSession();\n            if (token) {\n                console.log('üîê Session is active');\n                // Token validation happens on API calls\n                // If token is expired, API will return 401 and user will need to sign in again\n            }\n            else {\n                console.log('üîê No active session');\n            }\n        }\n        catch (error) {\n            console.error('Session monitor error:', error);\n        }\n    }, 5 * 60 * 1000); // Every 5 minutes\n    console.log('üîê Session monitor started');\n}\n// Stop monitor on shutdown\nif (extensionAPI.runtime.onSuspend) {\n    extensionAPI.runtime.onSuspend.addListener(() => {\n        console.log('üîê Stopping session monitor');\n        if (sessionRefreshInterval) {\n            clearInterval(sessionRefreshInterval);\n        }\n    });\n}\n// Handle extension icon click - open popup instead of direct capture\n// Note: Firefox uses browserAction, Chrome uses action\nconst actionAPI = extensionAPI.action || extensionAPI.browserAction;\nif (actionAPI && actionAPI.onClicked) {\n    actionAPI.onClicked.addListener(async (tab) => {\n        // The popup will handle the interaction\n        console.log('Extension clicked on tab:', tab?.url);\n    });\n}\nelse {\n    console.log('üîß Action API not available (popup will be used instead)');\n}\n// Global capture state\nlet currentCaptureController = null;\n// Handle messages from content script and popup\nextensionAPI.runtime.onMessage.addListener((message, sender, sendResponse) => {\n    log('Background received message:', message);\n    switch (message.type) {\n        case 'CAPTURE_PAGE':\n            handlePageCaptureWithActiveTab(message.payload);\n            break;\n        case 'CANCEL_CAPTURE':\n            handleCancelCapture();\n            break;\n        case 'GET_AUTH_TOKEN':\n            handleGetAuthToken(sendResponse);\n            return true; // Keep message channel open for async response\n        case 'AUTHENTICATE':\n            handleAuthenticate(message.payload, sendResponse);\n            return true; // Keep message channel open for async response\n        case 'SIGN_OUT':\n            handleSignOut(sendResponse);\n            return true; // Keep message channel open for async response\n        case 'GET_FOLDERS':\n            handleGetFolders(sendResponse);\n            return true; // Keep message channel open for async response\n        case 'GET_USAGE':\n            handleGetUsage(sendResponse);\n            return true; // Keep message channel open for async response\n        case 'CREATE_FOLDER':\n            handleCreateFolder(message.payload, sendResponse);\n            return true; // Keep message channel open for async response\n        default:\n            console.warn('Unknown message type:', message.type);\n    }\n});\nfunction handleCancelCapture() {\n    console.log('Cancelling current capture...');\n    if (currentCaptureController) {\n        currentCaptureController.abort();\n        currentCaptureController = null;\n    }\n    extensionAPI.runtime.sendMessage({\n        type: 'CAPTURE_PROGRESS',\n        payload: { status: 'cancelled', message: 'Capture cancelled by user' }\n    });\n}\nasync function handlePageCaptureWithActiveTab(payload) {\n    try {\n        // Get the active tab since popup messages don't have sender.tab\n        const [activeTab] = await extensionAPI.tabs.query({ active: true, currentWindow: true });\n        if (!activeTab) {\n            console.error('No active tab found');\n            extensionAPI.runtime.sendMessage({\n                type: 'CAPTURE_PROGRESS',\n                payload: { status: 'error', message: 'No active tab found' }\n            });\n            return;\n        }\n        console.log('Found active tab:', activeTab.url);\n        await handlePageCapture(payload, activeTab);\n    }\n    catch (error) {\n        console.error('Failed to get active tab:', error);\n        extensionAPI.runtime.sendMessage({\n            type: 'CAPTURE_PROGRESS',\n            payload: { status: 'error', message: 'Failed to access active tab' }\n        });\n    }\n}\nasync function handlePageCapture(payload, tab) {\n    if (!tab?.id) {\n        console.error('No tab ID provided for capture');\n        extensionAPI.runtime.sendMessage({\n            type: 'CAPTURE_PROGRESS',\n            payload: { status: 'error', message: 'No active tab found' }\n        });\n        return;\n    }\n    // Create abort controller for this capture\n    currentCaptureController = new AbortController();\n    const signal = currentCaptureController.signal;\n    // Set up timeout (120 seconds for full page, 15 seconds for visible)\n    const captureType = payload.captureType || 'fullPage';\n    const timeoutMs = captureType === 'fullPage' ? 120000 : 15000;\n    const timeoutId = setTimeout(() => {\n        if (currentCaptureController) {\n            currentCaptureController.abort();\n            const errorMsg = captureType === 'fullPage'\n                ? 'This page is very large and took too long to capture. Try capturing just the visible area instead.'\n                : 'Capture timed out. Please try again.';\n            extensionAPI.runtime.sendMessage({\n                type: 'CAPTURE_PROGRESS',\n                payload: { status: 'error', message: errorMsg }\n            });\n        }\n    }, timeoutMs);\n    try {\n        log('Starting page capture:', payload.url);\n        // Check if cancelled\n        if (signal.aborted) {\n            clearTimeout(timeoutId);\n            return;\n        }\n        // Step 1: Get page content from content script\n        extensionAPI.runtime.sendMessage({\n            type: 'CAPTURE_PROGRESS',\n            payload: { status: 'extracting', message: 'Extracting page content...' }\n        });\n        let pageContent = {};\n        try {\n            // Send message to content script to extract page data (Firefox compatible)\n            const response = await extensionAPI.tabs.sendMessage(tab.id, {\n                type: 'EXTRACT_PAGE_DATA'\n            });\n            if (response && response.success) {\n                pageContent = response.data;\n                console.log('‚úÖ Page content extracted from content script:', {\n                    htmlLength: pageContent.html?.length || 0,\n                    textLength: pageContent.text?.length || 0,\n                    title: pageContent.title\n                });\n                if (!pageContent.html || pageContent.html.length === 0) {\n                    console.warn('‚ö†Ô∏è Content script returned empty HTML!');\n                }\n                if (!pageContent.text || pageContent.text.length === 0) {\n                    console.warn('‚ö†Ô∏è Content script returned empty text!');\n                }\n            }\n            else {\n                console.warn('‚ö†Ô∏è Failed to extract page content from content script:', response);\n                console.warn('‚ö†Ô∏è Using fallback data from popup (may be empty)');\n                // Use fallback data from popup\n                pageContent = {\n                    url: payload.url,\n                    title: payload.title,\n                    html: payload.html || '',\n                    text: payload.text || '',\n                    favicon: payload.favicon\n                };\n            }\n        }\n        catch (contentError) {\n            console.warn('‚ö†Ô∏è Content script not available, trying dynamic injection:', contentError);\n            // Try to dynamically inject and extract content\n            try {\n                const extractionResults = await extensionAPI.scripting.executeScript({\n                    target: { tabId: tab.id },\n                    func: () => {\n                        // Inline content extraction function\n                        const html = document.documentElement.outerHTML;\n                        const cleanedHtml = html\n                            .replace(/<script\\b[^<]*(?:(?!<\\/script>)<[^<]*)*<\\/script>/gi, '')\n                            .replace(/<style\\b[^<]*(?:(?!<\\/style>)<[^<]*)*<\\/style>/gi, '')\n                            .replace(/<noscript\\b[^<]*(?:(?!<\\/noscript>)<[^<]*)*<\\/noscript>/gi, '');\n                        const text = cleanedHtml\n                            .replace(/<[^>]*>/g, ' ')\n                            .replace(/&nbsp;/g, ' ')\n                            .replace(/&amp;/g, '&')\n                            .replace(/&lt;/g, '<')\n                            .replace(/&gt;/g, '>')\n                            .replace(/\\s+/g, ' ')\n                            .trim();\n                        const faviconLink = document.querySelector('link[rel*=\"icon\"]');\n                        const favicon = faviconLink?.href || `${window.location.protocol}//${window.location.host}/favicon.ico`;\n                        return {\n                            url: window.location.href,\n                            title: document.title || '',\n                            html: cleanedHtml,\n                            text: text,\n                            favicon: favicon\n                        };\n                    }\n                });\n                if (extractionResults && extractionResults[0]?.result) {\n                    pageContent = extractionResults[0].result;\n                    console.log('‚úÖ Content extracted via dynamic injection:', {\n                        htmlLength: pageContent.html?.length || 0,\n                        textLength: pageContent.text?.length || 0,\n                        title: pageContent.title\n                    });\n                }\n                else {\n                    throw new Error('Dynamic extraction returned no results');\n                }\n            }\n            catch (dynamicError) {\n                console.error('‚ùå Dynamic content extraction failed:', dynamicError);\n                // Final fallback\n                pageContent = {\n                    url: payload.url,\n                    title: payload.title,\n                    html: '',\n                    text: '',\n                    favicon: payload.favicon\n                };\n            }\n        }\n        // Check if cancelled after content extraction\n        if (signal.aborted) {\n            clearTimeout(timeoutId);\n            return;\n        }\n        // Step 2: Capture screenshot\n        let screenshot;\n        if (captureType === 'fullPage' && FullPageCapture.isSupported()) {\n            console.log('Starting full-page capture for:', payload.url);\n            // Send progress message to popup\n            extensionAPI.runtime.sendMessage({\n                type: 'CAPTURE_PROGRESS',\n                payload: { status: 'capturing', message: 'Capturing full page...' }\n            });\n            const result = await FullPageCapture.captureFullPage(tab.id, {\n                quality: 90,\n                format: 'png',\n                scrollDelay: 500, // Increased to match the rate limiting\n            });\n            // Check if cancelled during capture\n            if (signal.aborted) {\n                clearTimeout(timeoutId);\n                return;\n            }\n            screenshot = result.dataUrl;\n            console.log(`Full-page capture completed: ${result.width}x${result.height}px in ${result.captureTime}ms`);\n        }\n        else {\n            // Fallback to visible area capture\n            console.log('Capturing visible area for:', payload.url);\n            extensionAPI.runtime.sendMessage({\n                type: 'CAPTURE_PROGRESS',\n                payload: { status: 'capturing', message: 'Capturing visible area...' }\n            });\n            screenshot = await extensionAPI.tabs.captureVisibleTab(tab.windowId, {\n                format: 'png',\n                quality: 90\n            });\n        }\n        // Check if cancelled after capture\n        if (signal.aborted) {\n            clearTimeout(timeoutId);\n            return;\n        }\n        console.log('Screenshot captured successfully');\n        // Send saving progress\n        extensionAPI.runtime.sendMessage({\n            type: 'CAPTURE_PROGRESS',\n            payload: { status: 'saving', message: 'Saving capture...' }\n        });\n        // Prepare clip data using extracted page content\n        const clipData = {\n            url: pageContent.url || payload.url,\n            title: pageContent.title || payload.title,\n            screenshot_data: screenshot,\n            html_content: pageContent.html || '',\n            text_content: pageContent.text || '',\n            // Use favicon from content script or fallback to popup data\n            ...((pageContent.favicon || payload.favicon) && (pageContent.favicon || payload.favicon).startsWith('http')\n                ? { favicon_url: pageContent.favicon || payload.favicon }\n                : {}),\n            // Include folder ID if provided\n            ...(payload.folderId ? { folder_id: payload.folderId } : {}),\n        };\n        console.log('‚úÖ Prepared clip data:', {\n            url: clipData.url,\n            title: clipData.title,\n            hasScreenshot: !!clipData.screenshot_data,\n            htmlLength: clipData.html_content.length,\n            textLength: clipData.text_content.length,\n            hasFavicon: !!clipData.favicon_url\n        });\n        // DEBUG: Check if content is actually empty\n        if (!clipData.html_content || clipData.html_content.length === 0) {\n            console.warn('‚ö†Ô∏è WARNING: html_content is empty!');\n        }\n        if (!clipData.text_content || clipData.text_content.length === 0) {\n            console.warn('‚ö†Ô∏è WARNING: text_content is empty!');\n        }\n        // Check if user is authenticated\n        const { token } = await ExtensionAuth.getSession();\n        if (token) {\n            try {\n                // Save to Supabase\n                const saveResult = await ExtensionAPI.saveClip(clipData);\n                console.log('Clip saved to Supabase successfully');\n                // Check if cancelled during save\n                if (signal.aborted) {\n                    clearTimeout(timeoutId);\n                    return;\n                }\n                // Send success message to popup with usage data\n                extensionAPI.runtime.sendMessage({\n                    type: 'CAPTURE_PROGRESS',\n                    payload: {\n                        status: 'complete',\n                        message: 'Capture saved to cloud!',\n                        usage: saveResult.usage // Include usage data from API response\n                    }\n                });\n            }\n            catch (error) {\n                console.error('Failed to save to Supabase:', error);\n                // Check if cancelled during error handling\n                if (signal.aborted) {\n                    clearTimeout(timeoutId);\n                    return;\n                }\n                // Fallback to local storage\n                await saveClipLocally(clipData);\n                // Send success message (local only)\n                extensionAPI.runtime.sendMessage({\n                    type: 'CAPTURE_PROGRESS',\n                    payload: { status: 'complete', message: 'Capture saved locally (will sync when online)' }\n                });\n            }\n        }\n        else {\n            // Save locally when not authenticated\n            await saveClipLocally(clipData);\n            // Send success message (local only)\n            extensionAPI.runtime.sendMessage({\n                type: 'CAPTURE_PROGRESS',\n                payload: { status: 'complete', message: 'Capture saved locally (sign in to sync)' }\n            });\n        }\n        // Update capture count\n        extensionAPI.storage.local.get(['captureCount'], (result) => {\n            const newCount = (result.captureCount || 0) + 1;\n            extensionAPI.storage.local.set({ captureCount: newCount });\n        });\n        // Clear timeout and controller\n        clearTimeout(timeoutId);\n        currentCaptureController = null;\n    }\n    catch (error) {\n        console.error('Failed to capture page:', error);\n        // Clear timeout and controller\n        clearTimeout(timeoutId);\n        currentCaptureController = null;\n        // Don't send error if it was cancelled\n        if (signal.aborted) {\n            return;\n        }\n        // Send error message to popup\n        extensionAPI.runtime.sendMessage({\n            type: 'CAPTURE_PROGRESS',\n            payload: { status: 'error', message: error instanceof Error ? error.message : 'Capture failed' }\n        });\n    }\n}\nasync function saveClipLocally(clipData) {\n    return new Promise((resolve) => {\n        extensionAPI.storage.local.get(['localClips'], (result) => {\n            const localClips = result.localClips || [];\n            const newClip = {\n                ...clipData,\n                id: Date.now().toString(),\n                created_at: new Date().toISOString(),\n                synced: false,\n            };\n            localClips.unshift(newClip);\n            // Keep only last 100 local clips to avoid storage issues\n            if (localClips.length > 100) {\n                localClips.splice(100);\n            }\n            extensionAPI.storage.local.set({ localClips }, () => {\n                console.log('Clip saved locally');\n                resolve();\n            });\n        });\n    });\n}\nasync function handleGetAuthToken(sendResponse) {\n    try {\n        // Restore session if needed to ensure token is valid\n        await ExtensionAuth.restoreSession();\n        const { token } = await ExtensionAuth.getSession();\n        sendResponse({ token });\n    }\n    catch (error) {\n        console.error('Failed to get auth token:', error);\n        sendResponse({ token: null });\n    }\n}\nasync function handleAuthenticate(payload, sendResponse) {\n    try {\n        console.log('üîß Background: Handling authentication:', payload.isSignUp ? 'sign up' : 'sign in', 'for', payload.email);\n        let result;\n        if (payload.isSignUp) {\n            console.log('üîß Background: Calling ExtensionAuth.signUp');\n            result = await ExtensionAuth.signUp(payload.email, payload.password);\n        }\n        else {\n            console.log('üîß Background: Calling ExtensionAuth.signIn');\n            result = await ExtensionAuth.signIn(payload.email, payload.password);\n        }\n        console.log('üîß Background: Auth result:', {\n            hasData: !!result.data,\n            hasError: !!result.error,\n            errorMessage: result.error?.message\n        });\n        if (result.error) {\n            console.error('üîß Background: Authentication failed:', result.error);\n            sendResponse({ error: result.error });\n        }\n        else {\n            console.log('üîß Background: Authentication successful, sending response');\n            sendResponse({ data: result.data });\n        }\n    }\n    catch (error) {\n        console.error('üîß Background: Authentication error:', error);\n        sendResponse({ error: { message: 'Authentication failed. Please try again.' } });\n    }\n}\nasync function handleSignOut(sendResponse) {\n    try {\n        console.log('Handling sign out');\n        await ExtensionAuth.signOut();\n        sendResponse({ success: true });\n    }\n    catch (error) {\n        console.error('Sign out error:', error);\n        // Force local cleanup even if remote signout fails\n        await extensionAPI.storage.local.remove(['authToken', 'userEmail', 'userId', 'refreshToken']);\n        sendResponse({ success: true });\n    }\n}\nasync function handleGetFolders(sendResponse) {\n    try {\n        log('Getting user folders');\n        const folders = await ExtensionAPI.getFolders();\n        log('Folders retrieved:', folders.folders?.length || 0);\n        sendResponse(folders);\n    }\n    catch (error) {\n        console.error('Failed to get folders:', error);\n        sendResponse({\n            folders: []\n        });\n    }\n}\nasync function handleGetUsage(sendResponse) {\n    try {\n        log('Getting user usage data');\n        const usage = await ExtensionAPI.getUsage();\n        log('Usage retrieved - remaining:', usage.clips_remaining);\n        sendResponse(usage);\n    }\n    catch (error) {\n        console.error('Failed to get usage:', error);\n        sendResponse({\n            error: 'Failed to load usage data',\n            clips_remaining: 50,\n            clips_limit: 50,\n            subscription_tier: 'free',\n            warning_level: 'safe'\n        });\n    }\n}\nasync function handleCreateFolder(payload, sendResponse) {\n    try {\n        log('Creating folder:', payload.name);\n        const folder = await ExtensionAPI.createFolder(payload);\n        log('Folder created successfully');\n        sendResponse({ folder });\n    }\n    catch (error) {\n        console.error('Failed to create folder:', error);\n        sendResponse({\n            error: 'Failed to create folder'\n        });\n    }\n}\n// Sync local clips when user authenticates\nextensionAPI.storage.onChanged.addListener((changes, namespace) => {\n    if (namespace === 'local' && changes.authToken && changes.authToken.newValue) {\n        // User just authenticated, sync local clips\n        syncLocalClips();\n    }\n});\nasync function syncLocalClips() {\n    try {\n        const result = await new Promise((resolve) => {\n            extensionAPI.storage.local.get(['localClips'], (result) => {\n                resolve({ localClips: result.localClips || [] });\n            });\n        });\n        const unsyncedClips = result.localClips.filter(clip => !clip.synced);\n        if (unsyncedClips.length === 0) {\n            return;\n        }\n        console.log(`Syncing ${unsyncedClips.length} local clips...`);\n        for (const clip of unsyncedClips) {\n            try {\n                await ExtensionAPI.saveClip({\n                    url: clip.url,\n                    title: clip.title,\n                    screenshot_data: clip.screenshot_data,\n                    html_content: clip.html_content,\n                    text_content: clip.text_content,\n                    favicon_url: clip.favicon_url,\n                });\n                // Mark as synced\n                clip.synced = true;\n            }\n            catch (error) {\n                console.error('Failed to sync clip:', error);\n            }\n        }\n        // Update local storage with synced status\n        extensionAPI.storage.local.set({ localClips: result.localClips });\n        console.log('Local clips sync completed');\n    }\n    catch (error) {\n        console.error('Failed to sync local clips:', error);\n    }\n}\n"],"names":[],"sourceRoot":""}